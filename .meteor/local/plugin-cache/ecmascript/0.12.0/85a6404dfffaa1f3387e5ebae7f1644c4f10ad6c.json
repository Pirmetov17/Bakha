{"metadata":{},"options":{"plugins":[{"key":"base$1$0","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"Program":{"enter":[null],"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","throwIfNamespace":true,"useBuiltIns":false}},{"key":"base$1$1","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null]},"_exploded":true,"_verified":true},"options":{"generateLetDeclarations":true,"enforceStrictMode":false}},{"key":"base$0$1","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$2","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]},"ImportDeclaration":{"enter":[null,null]},"ClassProperty":{"enter":[null]},"ClassPrivateProperty":{"enter":[null]},"AssignmentPattern":{"enter":[null]},"TypeCastExpression":{"enter":[null,null]},"CallExpression":{"enter":[null]},"OptionalCallExpression":{"enter":[null]},"NewExpression":{"enter":[null]},"ImportSpecifier":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"AnyTypeAnnotation":{"enter":[null]},"ArrayTypeAnnotation":{"enter":[null]},"BooleanTypeAnnotation":{"enter":[null]},"BooleanLiteralTypeAnnotation":{"enter":[null]},"NullLiteralTypeAnnotation":{"enter":[null]},"ClassImplements":{"enter":[null]},"DeclareClass":{"enter":[null]},"DeclareFunction":{"enter":[null]},"DeclareInterface":{"enter":[null]},"DeclareModule":{"enter":[null]},"DeclareModuleExports":{"enter":[null]},"DeclareTypeAlias":{"enter":[null]},"DeclareOpaqueType":{"enter":[null]},"DeclareVariable":{"enter":[null]},"DeclareExportDeclaration":{"enter":[null]},"DeclareExportAllDeclaration":{"enter":[null]},"DeclaredPredicate":{"enter":[null]},"ExistsTypeAnnotation":{"enter":[null]},"FunctionTypeAnnotation":{"enter":[null]},"FunctionTypeParam":{"enter":[null]},"GenericTypeAnnotation":{"enter":[null]},"InferredPredicate":{"enter":[null]},"InterfaceExtends":{"enter":[null]},"InterfaceDeclaration":{"enter":[null]},"InterfaceTypeAnnotation":{"enter":[null]},"IntersectionTypeAnnotation":{"enter":[null]},"MixedTypeAnnotation":{"enter":[null]},"EmptyTypeAnnotation":{"enter":[null]},"NullableTypeAnnotation":{"enter":[null]},"NumberLiteralTypeAnnotation":{"enter":[null]},"NumberTypeAnnotation":{"enter":[null]},"ObjectTypeAnnotation":{"enter":[null]},"ObjectTypeInternalSlot":{"enter":[null]},"ObjectTypeCallProperty":{"enter":[null]},"ObjectTypeIndexer":{"enter":[null]},"ObjectTypeProperty":{"enter":[null]},"ObjectTypeSpreadProperty":{"enter":[null]},"OpaqueType":{"enter":[null]},"QualifiedTypeIdentifier":{"enter":[null]},"StringLiteralTypeAnnotation":{"enter":[null]},"StringTypeAnnotation":{"enter":[null]},"ThisTypeAnnotation":{"enter":[null]},"TupleTypeAnnotation":{"enter":[null]},"TypeofTypeAnnotation":{"enter":[null]},"TypeAlias":{"enter":[null]},"TypeAnnotation":{"enter":[null]},"TypeParameter":{"enter":[null]},"TypeParameterDeclaration":{"enter":[null]},"TypeParameterInstantiation":{"enter":[null]},"UnionTypeAnnotation":{"enter":[null]},"Variance":{"enter":[null]},"VoidTypeAnnotation":{"enter":[null]},"ExportAllDeclaration":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]}},"options":{}},{"key":"base$0$3","visitor":{"CallExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"MemberExpression":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true,"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{}},{"key":"base$0$4","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$5","visitor":{"_exploded":{},"_verified":{},"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ObjectExpression":{"enter":[null]},"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"transform-meteor-dynamic-import","visitor":{"_exploded":{},"_verified":{},"CallExpression":{"enter":[null]}},"options":{}},{"key":"base$0$8","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"base$0$9","visitor":{"Program":{"exit":[null]},"_exploded":true,"_verified":true},"options":{"allowTopLevelThis":true,"strictMode":false,"loose":true}},{"key":"base$0$10","visitor":{"_exploded":{},"_verified":{},"PrivateName":{"enter":[null]},"ClassDeclaration":{"enter":[null]},"ClassExpression":{"enter":[null]}},"options":{"loose":true}}],"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/admin/simple-todos/packages/lmieulet:meteor-coverage/server/services/source-map.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","jsx",["flow",{}],["flow",{}],"objectRestSpread","objectRestSpread","dynamicImport","asyncGenerators","classProperties","classPrivateProperties"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.x86_64"},"sourceFileName":"packages/lmieulet:meteor-coverage/server/services/source-map.js","filename":"/Users/admin/simple-todos/packages/lmieulet:meteor-coverage/server/services/source-map.js","passPerPreset":false,"envName":"development","cwd":"/Users/admin/simple-todos","root":"/Users/admin/simple-todos","presets":[],"generatorOpts":{"filename":"/Users/admin/simple-todos/packages/lmieulet:meteor-coverage/server/services/source-map.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/lmieulet:meteor-coverage/server/services/source-map.js"}},"code":"let Log;\nmodule.link(\"./../context/log\", {\n  default(v) {\n    Log = v;\n  }\n\n}, 0);\nlet Conf;\nmodule.link(\"./../context/conf\", {\n  default(v) {\n    Conf = v;\n  }\n\n}, 1);\nlet fs;\nmodule.link(\"fs\", {\n  default(v) {\n    fs = v;\n  }\n\n}, 2);\nlet path;\nmodule.link(\"path\", {\n  default(v) {\n    path = v;\n  }\n\n}, 3);\n\nconst homedir = Npm.require('homedir');\n\nconst istanbulAPI = Npm.require('istanbul-api');\n\nconst libSourceMaps = istanbulAPI.libSourceMaps;\nconst sourceMap = libSourceMaps.createSourceMapStore({\n  verbose: Conf.IS_COVERAGE_ACTIVE\n});\nconst meteorDir = Conf.COVERAGE_APP_FOLDER;\nconst splitToken = String.fromCharCode(56507) + 'app/'; // caution! magic character inside the SourceMap source(s) path\n\nconst abspath = {\n  local: path.join(__meteor_bootstrap__.serverDir, '..', '..', '..'),\n  // could use process.env.METEOR_SHELL_DIR too\n  currentBuild: path.join(__meteor_bootstrap__.serverDir, '..'),\n  serverSide: __meteor_bootstrap__.serverDir,\n  clientSide: path.join(__meteor_bootstrap__.serverDir, '..', 'web.browser'),\n  // Meteor packages folder can be overriden with the env var PACKAGE_DIRS, otherwise '$HOME/.meteor/packages'.\n  // Read https://guide.meteor.com/writing-atmosphere-packages.html#overriding-atmosphere-packages\n  packages: process.env.PACKAGE_DIRS || path.join(homedir(), '.meteor', 'packages')\n};\nconst rgx = {\n  meteorCompiledTemplate: /\\/template\\.[^\\.\\/]+\\.js$/,\n  meteorPackageMergedFile: /^\\/packages\\/(local-test_)?(?:([^\\/_]+)_)?([^\\/_]+).js$/,\n  meteorPackagePathTokens: /^(?:packages\\/|node_modules\\/meteor\\/)(?:local-test[_:])?(([^_:\\/]+[_:])?([^_:\\/]+))\\/(.*node_modules\\/)?(.*)$/,\n  meteorPUT: /^local-test:((?:[^_:\\/]+:)?[^_:\\/]+)$/,\n  packageJson: /^(?:\\.\\.\\/npm\\/node_modules\\/(.*)|\\.\\.\\/\\.\\.\\/(?:(?!node_modules).)*(.*)|.*node_modules\\/(.*))$/\n};\n\nisAccessible = function (path, mode = fs.R_OK, supressErrors = false) {\n  try {\n    fs.accessSync(path, mode);\n    return true;\n  } catch (e) {\n    /* istanbul ignore else */\n    if (!supressErrors) {\n      Log.error('Cannot access', path);\n    }\n\n    return false;\n  }\n};\n\nparseJSON = function (filePath, supressAccessErrors = false) {\n  /* istanbul ignore else */\n  if (isAccessible(filePath, fs.R_OK, supressAccessErrors)) {\n    try {\n      return JSON.parse(fs.readFileSync(filePath, 'utf8'));\n    } catch (e) {\n      /* istanbul ignore next: Meteor should have saved an invalid JSON, quite improbable */\n      Log.error('Invalid JSON:', filePath, e);\n    }\n  }\n};\n\ninitialSetup = function () {\n  // Get the resolved, compiled and used packages and their versions\n  let resolverResultPath = path.join(abspath.local, 'resolver-result-cache.json');\n  let resolverResult = parseJSON(resolverResultPath);\n  /* istanbul ignore next: ternary operator */\n\n  this.resolved = resolverResult ? resolverResult.lastOutput.answer : null;\n  /* istanbul ignore else */\n\n  if (Meteor.isPackageTest) {\n    /* istanbul ignore else */\n    if (this.resolved) {\n      // Find the package(s) under test (PUT)\n      for (let pkg in this.resolved) {\n        /* istanbul ignore else */\n        if (this.resolved.hasOwnProperty(pkg)) {\n          let match = rgx.meteorPUT.exec(pkg);\n          match && (this.PUT[match[1]] = true);\n        }\n      }\n\n      const PUTs = Object.keys(this.PUT);\n      /* istanbul ignore else */\n\n      if (PUTs.length) {\n        Log.info(`Packages under test (${PUTs.length}):`, PUTs.join(', '));\n      } else {\n        Log.error('No packages under test in test-packages mode');\n      }\n    } // Check if testing from inside (pkg/) or outside (app/). We test all the merged files of meteor package(s) tests(s)\n    // assuming that `meteor test-packages` was exec from the package folder which the merged test file belongs to:\n    //  - If none can be accessed, then command is exec from app-dir\n    //  - If one can be accessed, then command is exec from pkg-dir of that package\n    // The possibilities when testing packages are:\n    //  1. `app/packages/pkg$ meteor test-packages ...opts`     inside (COVERAGE_APP_FOLDER points to app/packages/pkg/), test N packages\n    //  2. `app/packages/pkg$ meteor test-packages ./ ...opts`  inside (COVERAGE_APP_FOLDER points to app/packages/pkg/), test 1 package\n    //  3. `app$ meteor test-packages ...opts`                  outside (COVERAGE_APP_FOLDER points to app/), test N packages\n    //  4. `app$ meteor test-packages author:pkg...opts`        outside (COVERAGE_APP_FOLDER points to app/), test 1 package\n    //  5. `app$ meteor test-packages packages/pkg...opts`      outside (COVERAGE_APP_FOLDER points to app/), test 1 package\n    // NOTE: `...opts` represents the remaining command options (`--driver-package`, etc.)\n\n\n    const sidePaths = {\n      load: abspath.serverSide,\n      manifest: abspath.clientSide\n    };\n\n    for (let key in sidePaths) {\n      /* istanbul ignore else */\n      if (sidePaths.hasOwnProperty(key)) {\n        const programPath = path.join(sidePaths[key], 'program.json');\n        const program = parseJSON(programPath);\n        /* istanbul ignore next: file automatically created by Meteor, so really rare to enter here */\n\n        if (!program) continue;\n\n        for (let file of program[key]) {\n          let isTestFile,\n              matchAuthor,\n              matchName,\n              match = rgx.meteorPackageMergedFile.exec(`/${file.path}`); // If it's a meteor package test(s) merged file and the package has tests (the merged file is created whether\n          // the package has tests file(s) declared in `package.js` inside `Package.onTest()` or not). The way to know\n          // whether the package has tests or not is looking at file.sourceMap: if it's empty, it has no tests.\n\n          /* istanbul ignore else */\n\n          if (match && match[1] && file.sourceMap) {\n            [, isTestFile, matchAuthor, matchName] = match;\n            const sourceMapPath = path.join(sidePaths[key], file.sourceMap);\n            const sourceMap = parseJSON(sourceMapPath);\n            /* istanbul ignore else */\n\n            if (!sourceMap) continue; // jump to the next file if SourceMap non-accessible or invalid\n            // A compiled test file (local-test_...) has only the declared test\n            // files inside `package.js` as its sources, so check the first one\n\n            this.testingFromPackageDir = `${matchAuthor}:${matchName}`;\n            let filepathToCheck = fixSourcePath.call(this, sourceMap.sources[0], null, meteorDir);\n\n            if (!isAccessible(filepathToCheck, fs.R_OK, true)) {\n              this.testingFromPackageDir = false;\n            } else {\n              break;\n            }\n          }\n        }\n      }\n      /* istanbul ignore else */\n\n\n      if (this.testingFromPackageDir) break;\n    }\n  }\n}; // Alter inside the source map the path of each sources\n\n\nalterSourceMapPaths = function (map, isClientSide) {\n  // Absolute path to sources of a Meteor package. PUTs are treated differently than normal because they\n  // might not exist at abspath.packages, so PUT packages always are resolved depending on\n  // COVERAGE_APP_FOLDER and whether `meteor test-packages` was executed from inside/outside the package\n  // folder. Sources base of any Meteor packages not under test is always resolved to abspath.packages\n  let sourcesBase, isTestFile, matchAuthor, matchName;\n  /* istanbul ignore else */\n\n  if (rgx.meteorPackageMergedFile.test(map.file)) {\n    [, isTestFile, matchAuthor, matchName] = rgx.meteorPackageMergedFile.exec(map.file);\n    /* istanbul ignore next: ternary operator */\n\n    const packageID = matchAuthor ? `${matchAuthor}:${matchName}` : matchName;\n\n    if (Meteor.isPackageTest && (!!isTestFile || this.PUT[packageID])) {\n      // If exec `meteor test-packages` from `meteor-app-dir/packages/pkg-dir/` then Meteor performs tests on ALL\n      // packages at `meteor-app-dir/packages`, just like exec `meteor test-packages` from `meteor-app-dir/`, but\n      // this affects `sourcesBase` for PUTs, because PUTs outside COVERAGE_APP_FOLDER must change their sourcesBase\n      if (this.testingFromPackageDir) {\n        sourcesBase = this.testingFromPackageDir === packageID ? meteorDir : path.join(meteorDir, '..', matchName);\n      } else {\n        sourcesBase = path.join(meteorDir, 'packages', matchName);\n      }\n    } else {\n      /* istanbul ignore else */\n      if (this.resolved[packageID]) {\n        /* istanbul ignore next: ternary operator */\n        const packageFolder = matchAuthor ? `${matchAuthor}_${matchName}` : matchName;\n        sourcesBase = path.join(abspath.packages, packageFolder, this.resolved[packageID], 'web.browser');\n      }\n    }\n  } // Get `node_modules` base path for this map.file\n\n\n  let nodeModulesBase,\n      program = parseJSON(path.join(abspath.serverSide, 'program.json'));\n  /* istanbul ignore else */\n\n  if (!isClientSide && program) {\n    // Find the item matching map.file path\n    const mergedPath = map.file.substr(1);\n\n    for (let file of program.load) {\n      /* istanbul ignore else */\n      if (file.path === mergedPath) {\n        /* istanbul ignore else */\n        if (file.node_modules) {\n          try {\n            nodeModulesBase = path.join(abspath.serverSide, file.node_modules);\n            nodeModulesBase = fs.realpathSync(nodeModulesBase); // usually a symlink\n          } catch (e) {\n            if (e.code === 'ENOENT') {\n              Log.info('File not found!', nodeModulesBase);\n            } else {\n              throw e;\n            }\n          }\n        }\n\n        break;\n      }\n    }\n  }\n  /* istanbul ignore else */\n\n\n  if (!nodeModulesBase && sourcesBase) {\n    // Try locating node_modules inside sourcesBase sibling `npm`\n    let sourcesSiblingFolder = path.join(sourcesBase, '..', 'npm', 'node_modules');\n    /* istanbul ignore else */\n\n    if (isAccessible(sourcesSiblingFolder, fs.R_OK, true)) {\n      nodeModulesBase = sourcesSiblingFolder;\n    }\n  } // Fix sources paths, but be aware that, although you might be tempted to remove items\n  // from map.{sources|contentSources} (like non-instrumentable files: *.css, *.json,...),\n  // you must NOT do it, because their indexes are still being used by the mappings and\n  // you'll get a sound `Error('No element indexed by {index}')`.\n\n\n  for (let i = 0; i < map.sources.length; i++) {\n    // Meteor templates are not saved into files, but included in sourcesContent\n\n    /* istanbul ignore else */\n    if (rgx.meteorCompiledTemplate.test(map.sources[i])) {\n      Log.info('Skipping Meteor template:', map.sources[i]);\n      continue;\n    }\n\n    let fixed = fixSourcePath.call(this, map.sources[i], nodeModulesBase, sourcesBase);\n\n    if (map.sources[i] === fixed) {\n      Log.error('Source could not be altered:', map.sources[i]);\n    } else if (isAccessible(fixed)) {\n      map.sources[i] = fixed;\n    } else {\n      Log.error('Altered source could not be accessed:', map.sources[i]);\n    }\n  }\n\n  return map;\n}; // Fixes path of a source (file) in the SourceMap of a concatenated Meteor package test file\n\n\nfixSourcePath = function (source, nodeModulesBase, sourcesBase) {\n  let match,\n      paths = source.split(splitToken).slice(1); // Skip sources with unknown syntax\n\n  /* istanbul ignore else */\n\n  if (!paths.length) {\n    Log.error('Source with unknown format:', source);\n    return source;\n  } // The source is the package.json of a NPM dependency. Catches all next patterns:\n  //  1. meteor://💻app/.npm/package/node_modules/minimatch/package.json\n  //    [1 may be @ nodeModulesBase (when non-PUT) or sourcesBase (when PUT)]\n  //  2. meteor://💻app/../npm/node_modules/meteor-babel-helpers/package.json (package NPM dep)\n  //  3. meteor://💻app/../../app-dir/node_modules/meteor-node-stubs/node_modules/string_decoder/package.json\u001b (app NPM dep)\n  //  4. meteor://💻app/node_modules/http-errors/node_modules/inherits/package.json\n  //  5. meteor://💻app/node_modules/content-type/package.json\n\n  /* istanbul ignore else */\n\n\n  if (paths[0].endsWith('/package.json')) {\n    match = rgx.packageJson.exec(paths[0]);\n    /* istanbul ignore else */\n\n    if (match) {\n      /* istanbul ignore else */\n      if (match[2]) {\n        // covers 3 (app NPM dep package.json)\n        return path.join(meteorDir, match[2]);\n      }\n      /* istanbul ignore else */\n\n\n      if (match[3] && nodeModulesBase) {\n        // covers 1 (when non-PUT), 4 and 5 (meteor pkg NPM dep package.json)\n        return path.join(nodeModulesBase, match[3]);\n      }\n\n      return path.join(sourcesBase, paths[0]); // covers 1 (when PUT) and 2\n    }\n  } // The source is a Meteor package file (NPM dep or own file). Catches all next patterns:\n  //  6. meteor://💻app/packages/lmieulet:meteor-coverage/server/index.js\n  //  7. meteor://💻app/packages/local-test:lmieulet:meteor-coverage/server/tests.js\n  //  8. meteor://💻app/node_modules/meteor/lmieulet:meteor-coverage/node_modules/minimatch/minimatch.js\n  //  9. meteor://💻app/node_modules/meteor/local-test:cgalvarez:my-package/tests/client/mocks.js\n  //  10. meteor://💻app/node_modules/meteor/local-test:cgalvarez:my-package/node_modules/chai-as-promised/lib/chai-as-promised.js\n  //  11. meteor://💻app/node_modules/meteor/local-test:kadira:flow-router/node_modules/page/node_modules/path-to-regexp/node_modules/isarray/index.js\n\n\n  let matchPackageID, matchAuthor, matchName, matchNpmDepPath, matchPath;\n  match = rgx.meteorPackagePathTokens.exec(paths[0]);\n  /* istanbul ignore else */\n\n  if (match) {\n    [, matchPackageID, matchAuthor, matchName, matchNpmDepPath, matchPath] = match;\n    /* istanbul ignore else */\n\n    if (this.PUT[matchPackageID]) {\n      // PUT\n\n      /* istanbul ignore else */\n      if (matchNpmDepPath) {\n        // There is no way to know a priori if it's a recursive dep or not\n        let recNpmDep = path.join(sourcesBase, '.npm', 'package', matchNpmDepPath, matchPath);\n        /* istanbul ignore else */\n\n        if (isAccessible(recNpmDep, fs.R_OK, true)) {\n          return recNpmDep; // check if recursive dep (11) of PUT\n        }\n\n        return path.join(sourcesBase, '.npm', 'package', 'node_modules', matchPath); // first level dep (10) of PUT\n      }\n\n      return path.join(sourcesBase, matchPath); // covers 6,7,8,9 when PUT\n    }\n    /* istanbul ignore else */\n\n\n    if (Meteor.isPackageTest) {\n      return path.join(matchNpmDepPath ? nodeModulesBase : sourcesBase, matchPath); // non PUT\n    } // Package inside app-dir/packages on `meteor test ...`\n\n\n    return path.join(meteorDir, 'packages', matchName, matchPath);\n  } // Meteor app file\n\n\n  return path.join(meteorDir, paths[0]);\n}; // Processes the source map (when exists) of an instrumented file to fix broken sources paths\n\n\nregisterSourceMap = function (filepath) {\n  const sourceMapPath = filepath + '.map';\n  let fileContent = parseJSON(sourceMapPath, true);\n\n  if (fileContent) {\n    Log.time('registerSourceMap', filepath);\n    fileContent = alterSourceMapPaths.call(this, fileContent, filepath.startsWith('../web.browser/') || filepath.startsWith(abspath.clientSide));\n    Log.info('Add source map for file', sourceMapPath);\n    sourceMap.registerMap(filepath, fileContent);\n    Log.timeEnd('registerSourceMap', filepath);\n  } else {\n    Log.info('Source map not found', sourceMapPath);\n  }\n};\n\nmodule.exportDefault(SourceMap = {\n  initialSetup,\n  lib: sourceMap,\n  PUT: {},\n  // Meteor package(s) under test\n  registerSourceMap,\n  resolved: undefined,\n  // Meteor packages in use and their version\n  testingFromPackageDir: undefined // Whether `meteor test-packages` is run from inside/outside the package dir\n\n});","map":{"version":3,"sources":["packages/lmieulet:meteor-coverage/server/services/source-map.js"],"names":["Log","module","link","default","v","Conf","fs","path","homedir","Npm","require","istanbulAPI","libSourceMaps","sourceMap","createSourceMapStore","verbose","IS_COVERAGE_ACTIVE","meteorDir","COVERAGE_APP_FOLDER","splitToken","String","fromCharCode","abspath","local","join","__meteor_bootstrap__","serverDir","currentBuild","serverSide","clientSide","packages","process","env","PACKAGE_DIRS","rgx","meteorCompiledTemplate","meteorPackageMergedFile","meteorPackagePathTokens","meteorPUT","packageJson","isAccessible","mode","R_OK","supressErrors","accessSync","e","error","parseJSON","filePath","supressAccessErrors","JSON","parse","readFileSync","initialSetup","resolverResultPath","resolverResult","resolved","lastOutput","answer","Meteor","isPackageTest","pkg","hasOwnProperty","match","exec","PUT","PUTs","Object","keys","length","info","sidePaths","load","manifest","key","programPath","program","file","isTestFile","matchAuthor","matchName","sourceMapPath","testingFromPackageDir","filepathToCheck","fixSourcePath","call","sources","alterSourceMapPaths","map","isClientSide","sourcesBase","test","packageID","packageFolder","nodeModulesBase","mergedPath","substr","node_modules","realpathSync","code","sourcesSiblingFolder","i","fixed","source","paths","split","slice","endsWith","matchPackageID","matchNpmDepPath","matchPath","recNpmDep","registerSourceMap","filepath","fileContent","time","startsWith","registerMap","timeEnd","exportDefault","SourceMap","lib","undefined"],"mappings":"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","sourcesContent":["import Log from './../context/log';\r\nimport Conf from './../context/conf';\r\nimport fs from 'fs';\r\nimport path from 'path';\r\n\r\nconst homedir = Npm.require('homedir');\r\nconst istanbulAPI = Npm.require('istanbul-api');\r\nconst libSourceMaps = istanbulAPI.libSourceMaps;\r\n\r\nconst sourceMap = libSourceMaps.createSourceMapStore({verbose: Conf.IS_COVERAGE_ACTIVE});\r\nconst meteorDir = Conf.COVERAGE_APP_FOLDER;\r\nconst splitToken = String.fromCharCode(56507) + 'app/'; // caution! magic character inside the SourceMap source(s) path\r\n\r\nconst abspath = {\r\n  local: path.join(__meteor_bootstrap__.serverDir, '..', '..', '..'), // could use process.env.METEOR_SHELL_DIR too\r\n  currentBuild: path.join(__meteor_bootstrap__.serverDir, '..'),\r\n  serverSide: __meteor_bootstrap__.serverDir,\r\n  clientSide: path.join(__meteor_bootstrap__.serverDir, '..', 'web.browser'),\r\n  // Meteor packages folder can be overriden with the env var PACKAGE_DIRS, otherwise '$HOME/.meteor/packages'.\r\n  // Read https://guide.meteor.com/writing-atmosphere-packages.html#overriding-atmosphere-packages\r\n  packages: process.env.PACKAGE_DIRS || path.join(homedir(), '.meteor', 'packages')\r\n};\r\nconst rgx = {\r\n  meteorCompiledTemplate: /\\/template\\.[^\\.\\/]+\\.js$/,\r\n  meteorPackageMergedFile: /^\\/packages\\/(local-test_)?(?:([^\\/_]+)_)?([^\\/_]+).js$/,\r\n  meteorPackagePathTokens: /^(?:packages\\/|node_modules\\/meteor\\/)(?:local-test[_:])?(([^_:\\/]+[_:])?([^_:\\/]+))\\/(.*node_modules\\/)?(.*)$/,\r\n  meteorPUT: /^local-test:((?:[^_:\\/]+:)?[^_:\\/]+)$/,\r\n  packageJson: /^(?:\\.\\.\\/npm\\/node_modules\\/(.*)|\\.\\.\\/\\.\\.\\/(?:(?!node_modules).)*(.*)|.*node_modules\\/(.*))$/\r\n};\r\n\r\nisAccessible = function(path, mode = fs.R_OK, supressErrors = false) {\r\n  try {\r\n    fs.accessSync(path, mode);\r\n    return true;\r\n  } catch (e) {\r\n    /* istanbul ignore else */\r\n    if (!supressErrors) {\r\n      Log.error('Cannot access', path);\r\n    }\r\n    return false;\r\n  }\r\n};\r\n\r\nparseJSON = function(filePath, supressAccessErrors = false) {\r\n  /* istanbul ignore else */\r\n  if (isAccessible(filePath, fs.R_OK, supressAccessErrors)) {\r\n    try {\r\n      return JSON.parse(fs.readFileSync(filePath, 'utf8'));\r\n    } catch(e) {\r\n      /* istanbul ignore next: Meteor should have saved an invalid JSON, quite improbable */\r\n      Log.error('Invalid JSON:', filePath, e);\r\n    }\r\n  }\r\n};\r\n\r\ninitialSetup = function () {\r\n  // Get the resolved, compiled and used packages and their versions\r\n  let resolverResultPath = path.join(abspath.local, 'resolver-result-cache.json');\r\n  let resolverResult = parseJSON(resolverResultPath);\r\n  /* istanbul ignore next: ternary operator */\r\n  this.resolved = resolverResult ? resolverResult.lastOutput.answer : null;\r\n\r\n  /* istanbul ignore else */\r\n  if (Meteor.isPackageTest) {\r\n    /* istanbul ignore else */\r\n    if (this.resolved) {\r\n      // Find the package(s) under test (PUT)\r\n      for (let pkg in this.resolved) {\r\n        /* istanbul ignore else */\r\n        if (this.resolved.hasOwnProperty(pkg)) {\r\n          let match = rgx.meteorPUT.exec(pkg);\r\n          match && (this.PUT[match[1]] = true);\r\n        }\r\n      }\r\n      const PUTs = Object.keys(this.PUT);\r\n      /* istanbul ignore else */\r\n      if (PUTs.length) {\r\n        Log.info(`Packages under test (${PUTs.length}):`, PUTs.join(', '));\r\n      } else {\r\n        Log.error('No packages under test in test-packages mode');\r\n      }\r\n    }\r\n\r\n    // Check if testing from inside (pkg/) or outside (app/). We test all the merged files of meteor package(s) tests(s)\r\n    // assuming that `meteor test-packages` was exec from the package folder which the merged test file belongs to:\r\n    //  - If none can be accessed, then command is exec from app-dir\r\n    //  - If one can be accessed, then command is exec from pkg-dir of that package\r\n    // The possibilities when testing packages are:\r\n    //  1. `app/packages/pkg$ meteor test-packages ...opts`     inside (COVERAGE_APP_FOLDER points to app/packages/pkg/), test N packages\r\n    //  2. `app/packages/pkg$ meteor test-packages ./ ...opts`  inside (COVERAGE_APP_FOLDER points to app/packages/pkg/), test 1 package\r\n    //  3. `app$ meteor test-packages ...opts`                  outside (COVERAGE_APP_FOLDER points to app/), test N packages\r\n    //  4. `app$ meteor test-packages author:pkg...opts`        outside (COVERAGE_APP_FOLDER points to app/), test 1 package\r\n    //  5. `app$ meteor test-packages packages/pkg...opts`      outside (COVERAGE_APP_FOLDER points to app/), test 1 package\r\n    // NOTE: `...opts` represents the remaining command options (`--driver-package`, etc.)\r\n    const sidePaths = {\r\n      load: abspath.serverSide,\r\n      manifest: abspath.clientSide\r\n    };\r\n    for (let key in sidePaths) {\r\n      /* istanbul ignore else */\r\n      if (sidePaths.hasOwnProperty(key)) {\r\n        const programPath = path.join(sidePaths[key], 'program.json');\r\n        const program = parseJSON(programPath);\r\n        /* istanbul ignore next: file automatically created by Meteor, so really rare to enter here */\r\n        if (!program) continue;\r\n\r\n        for (let file of program[key]) {\r\n          let isTestFile, matchAuthor, matchName, match = rgx.meteorPackageMergedFile.exec(`/${file.path}`);\r\n          // If it's a meteor package test(s) merged file and the package has tests (the merged file is created whether\r\n          // the package has tests file(s) declared in `package.js` inside `Package.onTest()` or not). The way to know\r\n          // whether the package has tests or not is looking at file.sourceMap: if it's empty, it has no tests.\r\n          /* istanbul ignore else */\r\n          if (match && match[1] && file.sourceMap) {\r\n            [, isTestFile, matchAuthor, matchName] = match;\r\n            const sourceMapPath = path.join(sidePaths[key], file.sourceMap);\r\n            const sourceMap = parseJSON(sourceMapPath);\r\n            /* istanbul ignore else */\r\n            if (!sourceMap) continue; // jump to the next file if SourceMap non-accessible or invalid\r\n\r\n            // A compiled test file (local-test_...) has only the declared test\r\n            // files inside `package.js` as its sources, so check the first one\r\n            this.testingFromPackageDir = `${matchAuthor}:${matchName}`;\r\n            let filepathToCheck = fixSourcePath.call(this, sourceMap.sources[0], null, meteorDir);\r\n            if (!isAccessible(filepathToCheck, fs.R_OK, true)) {\r\n              this.testingFromPackageDir = false;\r\n            } else {\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      /* istanbul ignore else */\r\n      if (this.testingFromPackageDir) break;\r\n    }\r\n  }\r\n};\r\n\r\n// Alter inside the source map the path of each sources\r\nalterSourceMapPaths = function (map, isClientSide) {\r\n  // Absolute path to sources of a Meteor package. PUTs are treated differently than normal because they\r\n  // might not exist at abspath.packages, so PUT packages always are resolved depending on\r\n  // COVERAGE_APP_FOLDER and whether `meteor test-packages` was executed from inside/outside the package\r\n  // folder. Sources base of any Meteor packages not under test is always resolved to abspath.packages\r\n  let sourcesBase, isTestFile, matchAuthor, matchName;\r\n  /* istanbul ignore else */\r\n  if (rgx.meteorPackageMergedFile.test(map.file)) {\r\n    [, isTestFile, matchAuthor, matchName] = rgx.meteorPackageMergedFile.exec(map.file);\r\n    /* istanbul ignore next: ternary operator */\r\n    const packageID = matchAuthor ? `${matchAuthor}:${matchName}` : matchName;\r\n    if (Meteor.isPackageTest && (!!isTestFile || this.PUT[packageID])) {\r\n      // If exec `meteor test-packages` from `meteor-app-dir/packages/pkg-dir/` then Meteor performs tests on ALL\r\n      // packages at `meteor-app-dir/packages`, just like exec `meteor test-packages` from `meteor-app-dir/`, but\r\n      // this affects `sourcesBase` for PUTs, because PUTs outside COVERAGE_APP_FOLDER must change their sourcesBase\r\n      if (this.testingFromPackageDir) {\r\n        sourcesBase = this.testingFromPackageDir === packageID ? meteorDir : path.join(meteorDir, '..', matchName);\r\n      } else {\r\n        sourcesBase = path.join(meteorDir, 'packages', matchName);\r\n      }\r\n    } else {\r\n      /* istanbul ignore else */\r\n      if (this.resolved[packageID]) {\r\n        /* istanbul ignore next: ternary operator */\r\n        const packageFolder = matchAuthor ? `${matchAuthor}_${matchName}` : matchName;\r\n        sourcesBase = path.join(abspath.packages, packageFolder, this.resolved[packageID], 'web.browser');\r\n      }\r\n    }\r\n  }\r\n\r\n  // Get `node_modules` base path for this map.file\r\n  let nodeModulesBase, program = parseJSON(path.join(abspath.serverSide, 'program.json'));\r\n  /* istanbul ignore else */\r\n  if (!isClientSide && program) {\r\n    // Find the item matching map.file path\r\n    const mergedPath = map.file.substr(1);\r\n    for (let file of program.load) {\r\n      /* istanbul ignore else */\r\n      if (file.path === mergedPath) {\r\n        /* istanbul ignore else */\r\n        if (file.node_modules) {\r\n           try {\r\n             nodeModulesBase = path.join(abspath.serverSide, file.node_modules);\r\n             nodeModulesBase = fs.realpathSync(nodeModulesBase); // usually a symlink\r\n          } catch (e) {\r\n             if (e.code === 'ENOENT') {\r\n               Log.info('File not found!', nodeModulesBase);\r\n            } else {\r\n               throw e;\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  /* istanbul ignore else */\r\n  if (!nodeModulesBase && sourcesBase) {\r\n    // Try locating node_modules inside sourcesBase sibling `npm`\r\n    let sourcesSiblingFolder = path.join(sourcesBase, '..', 'npm', 'node_modules');\r\n    /* istanbul ignore else */\r\n    if (isAccessible(sourcesSiblingFolder, fs.R_OK, true)) {\r\n      nodeModulesBase = sourcesSiblingFolder;\r\n    }\r\n  }\r\n\r\n  // Fix sources paths, but be aware that, although you might be tempted to remove items\r\n  // from map.{sources|contentSources} (like non-instrumentable files: *.css, *.json,...),\r\n  // you must NOT do it, because their indexes are still being used by the mappings and\r\n  // you'll get a sound `Error('No element indexed by {index}')`.\r\n  for (let i = 0; i < map.sources.length; i++) {\r\n    // Meteor templates are not saved into files, but included in sourcesContent\r\n    /* istanbul ignore else */\r\n    if (rgx.meteorCompiledTemplate.test(map.sources[i])) {\r\n      Log.info('Skipping Meteor template:', map.sources[i]);\r\n      continue;\r\n    }\r\n\r\n    let fixed = fixSourcePath.call(this, map.sources[i], nodeModulesBase, sourcesBase);\r\n\r\n    if (map.sources[i] === fixed) {\r\n      Log.error('Source could not be altered:', map.sources[i]);\r\n    } else if (isAccessible(fixed)) {\r\n      map.sources[i] = fixed;\r\n    } else {\r\n      Log.error('Altered source could not be accessed:', map.sources[i]);\r\n    }\r\n  }\r\n  return map;\r\n};\r\n\r\n// Fixes path of a source (file) in the SourceMap of a concatenated Meteor package test file\r\nfixSourcePath = function(source, nodeModulesBase, sourcesBase) {\r\n  let match, paths = source.split(splitToken).slice(1);\r\n\r\n  // Skip sources with unknown syntax\r\n  /* istanbul ignore else */\r\n  if (!paths.length) {\r\n    Log.error('Source with unknown format:', source);\r\n    return source;\r\n  }\r\n\r\n  // The source is the package.json of a NPM dependency. Catches all next patterns:\r\n  //  1. meteor://💻app/.npm/package/node_modules/minimatch/package.json\r\n  //    [1 may be @ nodeModulesBase (when non-PUT) or sourcesBase (when PUT)]\r\n  //  2. meteor://💻app/../npm/node_modules/meteor-babel-helpers/package.json (package NPM dep)\r\n  //  3. meteor://💻app/../../app-dir/node_modules/meteor-node-stubs/node_modules/string_decoder/package.json\u001b (app NPM dep)\r\n  //  4. meteor://💻app/node_modules/http-errors/node_modules/inherits/package.json\r\n  //  5. meteor://💻app/node_modules/content-type/package.json\r\n  /* istanbul ignore else */\r\n  if (paths[0].endsWith('/package.json')) {\r\n    match = rgx.packageJson.exec(paths[0]);\r\n    /* istanbul ignore else */\r\n    if (match) {\r\n      /* istanbul ignore else */\r\n      if (match[2]) { // covers 3 (app NPM dep package.json)\r\n        return path.join(meteorDir, match[2]);\r\n      }\r\n      /* istanbul ignore else */\r\n      if (match[3] && nodeModulesBase) {\r\n        // covers 1 (when non-PUT), 4 and 5 (meteor pkg NPM dep package.json)\r\n        return path.join(nodeModulesBase, match[3]);\r\n      }\r\n      return path.join(sourcesBase, paths[0]); // covers 1 (when PUT) and 2\r\n    }\r\n  }\r\n\r\n  // The source is a Meteor package file (NPM dep or own file). Catches all next patterns:\r\n  //  6. meteor://💻app/packages/lmieulet:meteor-coverage/server/index.js\r\n  //  7. meteor://💻app/packages/local-test:lmieulet:meteor-coverage/server/tests.js\r\n  //  8. meteor://💻app/node_modules/meteor/lmieulet:meteor-coverage/node_modules/minimatch/minimatch.js\r\n  //  9. meteor://💻app/node_modules/meteor/local-test:cgalvarez:my-package/tests/client/mocks.js\r\n  //  10. meteor://💻app/node_modules/meteor/local-test:cgalvarez:my-package/node_modules/chai-as-promised/lib/chai-as-promised.js\r\n  //  11. meteor://💻app/node_modules/meteor/local-test:kadira:flow-router/node_modules/page/node_modules/path-to-regexp/node_modules/isarray/index.js\r\n  let matchPackageID, matchAuthor, matchName, matchNpmDepPath, matchPath;\r\n  match = rgx.meteorPackagePathTokens.exec(paths[0]);\r\n  /* istanbul ignore else */\r\n  if (match) {\r\n    [, matchPackageID, matchAuthor, matchName, matchNpmDepPath, matchPath] = match;\r\n    /* istanbul ignore else */\r\n    if (this.PUT[matchPackageID]) { // PUT\r\n      /* istanbul ignore else */\r\n      if (matchNpmDepPath) {\r\n        // There is no way to know a priori if it's a recursive dep or not\r\n        let recNpmDep = path.join(sourcesBase, '.npm', 'package', matchNpmDepPath, matchPath);\r\n        /* istanbul ignore else */\r\n        if (isAccessible(recNpmDep, fs.R_OK, true)) {\r\n          return recNpmDep; // check if recursive dep (11) of PUT\r\n        }\r\n        return path.join(sourcesBase, '.npm', 'package', 'node_modules', matchPath); // first level dep (10) of PUT\r\n      }\r\n      return path.join(sourcesBase, matchPath); // covers 6,7,8,9 when PUT\r\n    }\r\n\r\n    /* istanbul ignore else */\r\n    if (Meteor.isPackageTest) {\r\n      return path.join(matchNpmDepPath ? nodeModulesBase : sourcesBase, matchPath); // non PUT\r\n    }\r\n\r\n    // Package inside app-dir/packages on `meteor test ...`\r\n    return path.join(meteorDir, 'packages', matchName, matchPath);\r\n  }\r\n\r\n  // Meteor app file\r\n  return path.join(meteorDir, paths[0]);\r\n};\r\n\r\n// Processes the source map (when exists) of an instrumented file to fix broken sources paths\r\nregisterSourceMap = function(filepath) {\r\n  const sourceMapPath = filepath + '.map';\r\n  let fileContent = parseJSON(sourceMapPath, true);\r\n  if (fileContent) {\r\n    Log.time('registerSourceMap', filepath);\r\n    fileContent = alterSourceMapPaths.call(this, fileContent,\r\n      filepath.startsWith('../web.browser/') || filepath.startsWith(abspath.clientSide));\r\n    Log.info('Add source map for file', sourceMapPath);\r\n    sourceMap.registerMap(filepath, fileContent);\r\n    Log.timeEnd('registerSourceMap', filepath);\r\n  } else {\r\n    Log.info('Source map not found', sourceMapPath);\r\n  }\r\n};\r\n\r\nexport default SourceMap = {\r\n  initialSetup,\r\n  lib: sourceMap,\r\n  PUT: {},                          // Meteor package(s) under test\r\n  registerSourceMap,\r\n  resolved: undefined,              // Meteor packages in use and their version\r\n  testingFromPackageDir: undefined  // Whether `meteor test-packages` is run from inside/outside the package dir\r\n};\r\n"]},"sourceType":"script","hash":"85a6404dfffaa1f3387e5ebae7f1644c4f10ad6c"}
